<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Warframe Weeklies Checklist</title>
  <link rel="stylesheet" href="style.css">

  <!-- Added CSS: equal-width buttons per row and small padding between them -->
  <style>
    :root{
      --btn-gap: 8px;
      --showhide-width: 56px;
      --btn-padding-vertical: 8px;
      --btn-padding-horizontal: 12px;
    }

    /* row container */
    .task-row {
      display: flex;
      gap: var(--btn-gap);
      margin-bottom: 8px;
      align-items: stretch;
    }

    /* each task cell becomes a flex item that shares available width equally */
    .task-item {
      display: flex;
      gap: 6px;
      align-items: center;
      flex: 1 1 0;
      min-width: 0; /* allow children to shrink properly */
    }

    /* main button takes remaining space inside the item */
    .task-item .toggle {
      flex: 1 1 0;
      width: 100%;
      padding: var(--btn-padding-vertical) var(--btn-padding-horizontal);
      box-sizing: border-box;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* small show/hide button kept for compatibility (per-item) */
    .task-item .showhide {
      flex: 0 0 var(--showhide-width);
      width: var(--showhide-width);
      padding: 6px;
      box-sizing: border-box;
    }

    /* row-level control: fixed-size control at end of row that hides/shows the whole line */
    .row-control {
      flex: 0 0 var(--showhide-width);
      display: flex;
      align-items: center;
      justify-content: center;
      width: var(--showhide-width);
      box-sizing: border-box;
    }
    .row-control button { padding:6px; }

    /* Use the same styling the edit button used previously for consistency */
    /* (these rely on theme vars set by the edit menu: --edit-btn, --reset-btn, --fg, --btn-text-size, --font-family) */
    #editBtn, #resetBtn, .row-control button {
      background: var(--edit-btn);
      color: var(--fg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      padding: 6px 10px;
      box-sizing: border-box;
      font-size: calc(var(--btn-text-size) - 2px);
      font-family: var(--font-family);
    }

    /* reset button uses its own accent */
    #resetBtn {
      background: var(--reset-btn);
    }

    /* small hover / active affordances */
    #editBtn:hover, .row-control button:hover, #resetBtn:hover {
      filter: brightness(1.06);
    }

    /* active state for row-control can indicate hidden/shown */
    .row-control button[data-hidden="true"] {
      opacity: 0.6;
    }
  </style>
</head>
<body>

<div id="main" style="margin-left: 50px;">
<h1 style="padding-right: 74px;">Weeklies</h1>  <div id="taskList"></div>
<button id="editBtn" style="padding-right: 10px;margin-right: 74px;">Toggle Edit Menu</button>
<button id="resetBtn" style="margin-right: 74px;">Reset All</button>

  <div id="editMenu">
    <h3>Edit Theme</h3>
    <div class="color-picker"><label>Page Background</label><input type="color" id="bgPicker"></div>
    <div class="color-picker"><label>Text</label><input type="color" id="textPicker"></div>
    <div class="color-picker"><label>Uncompleted</label><input type="color" id="btnOffPicker"></div>
    <div class="color-picker"><label>Compelted</label><input type="color" id="btnOnPicker"></div>
    <div class="color-picker"><label>Edit Button</label><input type="color" id="editBtnPicker"></div>
    <div class="color-picker"><label>Reset Button</label><input type="color" id="resetBtnPicker"></div>
    <div class="color-picker"><label>Edit Menu Background</label><input type="color" id="editMenuBgPicker"></div>
    <div class="color-picker"><label>Text Size </label><input type="range" id="textSizePicker" min="8" max="48" value="16"> <span id="textSizeValue">16</span> px</div>
    <div class="color-picker"><label>Font</label><select id="fontPicker"></select></div>
  </div>
</div>

<script>
let tasksRaw = [];
let rows = [];
let flatTasks = [];
let state = [];
let visibility = [];
let rowVisibility = [];            // NEW: visibility per-row
const presetFonts = ["Arial", "Verdana", "Tahoma", "Georgia", "Courier New", "Times New Roman"];

// Default theme colors
const defaultTheme = {
  '--bg': '#1a1a1a',
  '--fg': '#e6e6e6',
  '--btn-bg': '#333',
  '--btn-active': '#4caf50',
  '--edit-btn': '#444',
  '--reset-btn': '#444',
  '--edit-menu-bg': '#222',
  '--btn-text-size': '16',
  '--font-family': 'Arial'
};

async function loadTasks() {
  const res = await fetch('tasks.json');
  const data = await res.json();
  tasksRaw = data.tasks || [];

  // Normalize into rows: items that are arrays become rows, single objects become single-item rows
  rows = tasksRaw.map(t => Array.isArray(t) ? t : [t]);
  flatTasks = rows.flat();

  // normalize persisted state/visibility to match current tasks count
  const savedState = JSON.parse(localStorage.getItem('state')) || [];
  const savedVis = JSON.parse(localStorage.getItem('visibility')) || [];
  state = flatTasks.map((_, i) => (i < savedState.length ? !!savedState[i] : false));
  visibility = flatTasks.map((_, i) => (i < savedVis.length ? !!savedVis[i] : true));
  // persist normalized arrays so future loads are consistent
  localStorage.setItem('state', JSON.stringify(state));
  localStorage.setItem('visibility', JSON.stringify(visibility));

  // NEW: load or normalize row-level visibility
  const savedRowVis = JSON.parse(localStorage.getItem('rowVisibility')) || null;
  if (Array.isArray(savedRowVis)) {
    // use saved row-level visibility (normalize length)
    rowVisibility = rows.map((_, i) => (i < savedRowVis.length ? !!savedRowVis[i] : true));
  } else {
    // derive row visibility from per-item visibility if no rowVisibility stored
    let idx = 0;
    rowVisibility = rows.map(rowTasks => {
      const anyVisible = rowTasks.some(() => {
        const v = (idx < visibility.length) ? visibility[idx] : true;
        idx++;
        return v;
      });
      return anyVisible;
    });
  }
  localStorage.setItem('rowVisibility', JSON.stringify(rowVisibility));

  renderTasks();
}

const taskList = document.getElementById('taskList');
const editMenu = document.getElementById('editMenu');
const editBtn = document.getElementById('editBtn');
const resetBtn = document.getElementById('resetBtn');
const fontPicker = document.getElementById('fontPicker');
const textSizePicker = document.getElementById('textSizePicker');
const textSizeValue = document.getElementById('textSizeValue');
const editMenuBgPicker = document.getElementById('editMenuBgPicker');

presetFonts.forEach(f => {
  const option = document.createElement('option');
  option.value = f;
  option.textContent = f;
  fontPicker.appendChild(option);
});

const colorInputs = {
  bgPicker: '--bg',
  textPicker: '--fg',
  btnOffPicker: '--btn-bg',
  btnOnPicker: '--btn-active',
  editBtnPicker: '--edit-btn',
  resetBtnPicker: '--reset-btn',
  editMenuBgPicker: '--edit-menu-bg',
  textSizePicker: '--btn-text-size',
  fontPicker: '--font-family'
};

// Initialize theme with saved values or defaults
Object.keys(colorInputs).forEach(id => {
  const varName = colorInputs[id];
  let saved = localStorage.getItem(varName);
  if (!saved) saved = defaultTheme[varName];

  if(id === 'textSizePicker') {
    document.documentElement.style.setProperty(varName, saved + 'px');
    textSizePicker.value = saved;
    textSizeValue.textContent = saved;
  } else if(id === 'fontPicker') {
    document.documentElement.style.setProperty(varName, saved);
    fontPicker.value = saved;
  } else {
    document.documentElement.style.setProperty(varName, saved);
    if(id === 'editMenuBgPicker') editMenu.style.background = saved;
  }
});

textSizePicker.addEventListener('input', e => {
  const val = e.target.value;
  document.documentElement.style.setProperty('--btn-text-size', val + 'px');
  textSizeValue.textContent = val;
  localStorage.setItem('--btn-text-size', val);
});

fontPicker.addEventListener('change', e => {
  const val = e.target.value;
  document.documentElement.style.setProperty('--font-family', val);
  localStorage.setItem('--font-family', val);
});

editMenuBgPicker.addEventListener('input', e => {
  const val = e.target.value;
  document.documentElement.style.setProperty('--edit-menu-bg', val);
  editMenu.style.background = val;
  localStorage.setItem('--edit-menu-bg', val);
});

Object.keys(colorInputs).forEach(id => {
  if(!['textSizePicker','fontPicker','editMenuBgPicker'].includes(id)) {
    const el = document.getElementById(id);
    el.addEventListener('input', e => {
      const val = e.target.value;
      document.documentElement.style.setProperty(colorInputs[id], val);
      localStorage.setItem(colorInputs[id], val);
    });
  }
});

function save() {
  localStorage.setItem('state', JSON.stringify(state));
  localStorage.setItem('visibility', JSON.stringify(visibility));
  localStorage.setItem('rowVisibility', JSON.stringify(rowVisibility)); // persist row visibility too
}

function renderTasks() {
  taskList.innerHTML = '';
  const editOpen = editMenu.classList.contains('open');
  let counter = 0; // index into flatTasks/state/visibility

  rows.forEach((rowTasks, rowIndex) => {
    const row = document.createElement('div');
    row.className = 'task-row';
    let visibleInRow = 0;

    rowTasks.forEach(t => {
      const i = counter++;
      const item = document.createElement('div');
      item.className = 'task-item';

      const btn = document.createElement('button');
      btn.className = 'toggle' + (state[i] ? ' active' : '');
      btn.textContent = t.label || t.name || 'Task';
      btn.style.fontSize = `var(--btn-text-size)`;
      btn.style.fontFamily = `var(--font-family)`;
      btn.onclick = () => {
        state[i] = !state[i];
        save();
        renderTasks();
      };

      // Visibility now considers both per-item visibility and the row-level visibility
      const rowVisible = rowVisibility[rowIndex];
      const itemVisible = !!visibility[i];
      if (!itemVisible || !rowVisible) {
        if (editOpen) {
          btn.style.opacity = '0.3';
        } else {
          item.style.display = 'none';
        }
      } else {
        btn.style.opacity = '1';
        visibleInRow++;
      }

      item.appendChild(btn);
      row.appendChild(item);
    });

    // Create a single row-level show/hide control (hides/shows the whole line)
    const rowCtrl = document.createElement('div');
    rowCtrl.className = 'row-control';
    const rowBtn = document.createElement('button');
    rowBtn.textContent = rowVisibility[rowIndex] ? 'Hide' : 'Show';
    rowBtn.dataset.hidden = (!rowVisibility[rowIndex]).toString(); // reflect state for CSS
    rowBtn.style.display = editOpen ? 'block' : 'none';
    rowBtn.onclick = () => {
      // toggle row visibility and also update per-item visibility for that row so behavior is consistent
      rowVisibility[rowIndex] = !rowVisibility[rowIndex];

      // compute start index for this row in flatTasks
      let startIndex = 0;
      for (let r = 0; r < rowIndex; r++) startIndex += rows[r].length;

      for (let j = 0; j < rows[rowIndex].length; j++) {
        const idx = startIndex + j;
        // set per-item visibility to match the row-level choice
        visibility[idx] = rowVisibility[rowIndex];
      }

      save(); // now also persists rowVisibility
      renderTasks();
    };
    rowCtrl.appendChild(rowBtn);
    row.appendChild(rowCtrl);

    // If row has no visible items and we're not in edit mode, hide the whole row
    if (!editOpen && (visibleInRow === 0 || !rowVisibility[rowIndex])) {
      row.style.display = 'none';
    } else {
      row.style.display = 'flex';
    }

    taskList.appendChild(row);
  });
}

editBtn.onclick = () => {
  editMenu.classList.toggle('open');
  renderTasks();
};

resetBtn.onclick = () => {
  // reset to false for all flat tasks
  state = flatTasks.map(() => false);
  save();
  renderTasks();
};

loadTasks();
</script>

</body>
</html>


